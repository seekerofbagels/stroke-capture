# stroke-capture
## Overview
I attempt to emulate human mouse movement where I capture the process of seeing a point of interest (say an exit button) and moving the mouse to click it. The model requires the mouse position and a single position that the mouse wishes to move to. It outputs a trajectory for the mouse to take.

Dissecting the mouse movement, we notics a reaction time where the mouse is still, followed by the mouse moving toward the target point. The reaction time can easily be modelled, but what to do with the mouse movement must be considered carefully. We desire the model to pass off as human, so the accuracy of the model will be subjective, and there are no apparent loss functions that measure 'human-likeness'. A simple distance loss over the entire trajectory is not useful since there is an infinite number of ways for a human to move the mouse between two fixed points, and being close in distance to one 'human movement' is not close to another. There isn't an objectively most human trajectory for the model to compare to, but that also means the model doesn't need to give a correct answer. However there are some requirements on the output: the trajectory should be smooth, among other physical limitations. This leads to a natural idea for the model to forecast the next position of the mouse based on its recent positions.

There are many advantages to the forecasting method. We place a focus on the local behaviour and hope that some global behaviour emerges. We can use L2 loss for each local input window since locally all human movement must obey the laws of physics. We have also broken up the input-output shape from two positional argument->sixty or so points in a trajectory to four recent positions->next position, making training the model actually possible. I have decided against using a recursive neural network here because I judge that long-term memory of what the trajectory looks like would either be ignored by the model or make the model too complicated and absorb too much noise. I have also made sure that the target point is always centred at (0,0) to naturally bake in where the model needs to go without too much complication. All these precautions limit the degree of freedom of the input and output so that I can hopefully capture useful information with limited amount of data.

There are problems that arises from only looking at local behaviour. Although the generated trajectories are smooth and moves toward the target point, it tends to buckle near the endpoint due to the forecasting method accumulating error every frame and veering progressively off-course. To combat this I introduced a target-seeking mechanism where each frame there is a random probability for the generated point to be rotated toward the target. Such probabilistic method should cancel the exponential accumulation of error nicely. One might ask if such a large part of the output relies on a random variable, then what is the point of the model? Is the machine learning even necessary? The model here is crucial in establishing an assymetrical smooth trajectory which is very efficient compared to constructing a model using only random variables by hand.

Some improvements to the model can be made by increasing the frame rate with according adjustments to the parameters of the seeker. I can utilise the variance of the error between the model prediction and training data to add a layer of noise and make the trajectory less rigid. I can implement a training algorithm for the seeking mechanism: currently the parameters are manually controlled because I have yet to find a loss function to train global behaviour. This may be done by looking deeper into how tensorflow implements differentiation in the loss function.

## Usage
Run `raw_data_capture.py` to manually record data in a minigame. The data will be recorded in a csv format in `data`.
Run `trim_raw_data.py` for the necessary preprocessing.
Run `model_reaction_time.py` to train a model for the initial reaction time portion of the prediction.
In `model.py`, use `compile_and_save` to train a model. The input window sizes can be customised and the direction of `DataImporter` can be flipped to train backward models, although the performance of backward models are not desirable.
`simulate.py` uses pyglet to display predictions of the models. `RecordReplay` replays the stored data; `Forecaster` uses the two models specified in path to predict a trajectory given two positional argument as input; `SeekingForecaster` uses the above mentioned probabilistic seeker to help improve prediction, parameters need to be changed manually.
Note that the positions are based on what pyglet uses. The modellying process uses tensorflow and keras.
